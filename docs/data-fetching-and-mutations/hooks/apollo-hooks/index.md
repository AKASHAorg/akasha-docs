# Apollo Hooks
This section provides in-depth information on the hooks for Apollo mutations and queries automatically generated by the GraphQL CodeGen tool.

## Mutations
Mutations are often used to interact with the GraphQL API resulting to changes (creating / updating) to the underlying model's data.
When initializing a mutation hook, it is important to pass to it a `context` which provides a different network endpoint needed by the mutations. Calling a mutation returns a tuple that includes:
- A `mutate` function that you can call at any time to execute the mutation.
- An object with fields that represent the current status of the mutation's execution.

### useCreateAppMutation
Create an application with **useCreateAppMutation**

> This hook provides the mutation function to create the underlying model's data. It is helpful in creating robust applications.

**Example usage**
```jsx
import { useCreateAppMutation } from  '@akashaorg/ui-awf-hooks/lib/generated'
import getSDK from '@akashaorg/awf-sdk';

const sdk = getSDK();
const [createApp, { data, error, loading }] = useCreateAppMutation(
  {
    context: {
      source: sdk.services.gql.contextSources.composeDB
    },
  }
);

const handleCreateApp = () => {
  // call the mutation function
  createApp({
    variables: {
      i: {
        content: {
          name: 'appID',
          license: 'License',
          applicationType: 'APP',
          displayName: 'AmazingApp',
          description: 'this is an amazing app',
          createdAt: new Date().toISOString(),
        }
      }
    },
    onError, // fn to be called if the mutation fails
    OnCompleted, // fn to be called when the mutation completes execution
    ...
  }).then(resp => {
    // handle response data here
  }).catch(err => {
    // handle error message here
  })
}
```

### useCreateBeamMutation
Create a beam with **useCreateBeamMutation**

> This hook provides the mutation function to create the underlying model's data. It is helpful in creating beams during the blocks publishing process of the editor. These beams can then be viewed in an antenna app or any other list app curating beams.

**Example usage**
```jsx
import { useCreateBeamMutation } from  '@akashaorg/ui-awf-hooks/lib/generated'
import getSDK from '@akashaorg/awf-sdk';

const sdk = getSDK();
const [createBeam, { data, error, loading }] = useCreateBeamMutation(
  {
    context: {
      source: sdk.services.gql.contextSources.composeDB
    },
  }
);

const handleCreateBeam = () => {
  const tagLabelType = sdk.services.gql.labelTypes.TAG;
  createBeam({
    variables: {
      i: {
        content: {
          nsfw: false,
          active: true,
          content: [
            {
              blockID: 'blockID',
              order: 1
            }
          ],
          tags: [
            {
              labelType: tagLabelType
              value: 'akasha'
            },
            {
              labelType: tagLabelType
              value: 'world'
            },
          ],
          createdAt: new Date().toISOString(),
        }
      }
    },
    onError,
    OnCompleted,
    ...
  }).then(
    // ...
  ).catch(
    // ...
  )
}
```

### useCreateContentBlockMutation
Create a [content block](../../../extensions/editor/content_blocks.md) with **useCreateContentBlockMutation**

> This hook provides the mutation function to create the underlying model's data. It is helpful in creating content blocks during the blocks publishing process of the editor.

**Example usage**
```jsx
import { useCreateContentBlockMutation } from  '@akashaorg/ui-awf-hooks/lib/generated'

const [createContentBlock, { data, error, loading }] = useCreateContentBlockMutation();

const handleCreateContentBlock = () => {
  createContentBlock({
    variables: {
      i: {
        content: {
          nsfw: false,
          active: true,
          appVersionID: 'k2t6wzhkhabz3aut9p2mhjzp80hzo7bee18l1pt94syakfbfcj7phve27kiwwp',
          content: [{
            label: 'appName',
            propertyType: 'propertyType'
            value: 'content'
          }],
          kind: 'TEXT',
          createdAt: new Date().toISOString(),
        }
      }
    },
    onError,
    OnCompleted,
    ...
  }).then(
    // ...
  ).catch(
    // ...
  )
}
```

### useCreateFollowMutation
Create a follow document to a profile with **useCreateFollowMutation**

> This hook provides the mutation function to create the underlying model's data. It is helpful in keeping track of a profile's followers or following data.
The mutation is called only when there is no existing follow document id for the profile. If it exists, [useUpdateFollowMutation](#useupdatefollowmutation) should be used instead.

**Example usage**
```jsx
import { useCreateFollowMutation } from  '@akashaorg/ui-awf-hooks/lib/generated'
import getSDK from '@akashaorg/awf-sdk';

const sdk = getSDK();
const [createFollow, { data, error, loading }] = useCreateFollowMutation(
  {
    context: {
      source: sdk.services.gql.contextSources.composeDB
    },
  }
);

const followId = null; // use createFollowMutation, only when there is no follow document id.

const handleCreateFollow = () => {
  if (!followId) {
    createFollow({
    variables: {
      i: {
        content: {
          isFollowing: true,
          profileID: 'did:pkh:eip155:11155111:0x2c953cd8d24004406570840a'
          createdAt: new Date().toISOString(),
        }
      }
    },
    onError,
    OnCompleted,
    ...
  }).then(
    // ...
  ).catch(
    // ...
  )
  }
}
```

### useCreateInterestsMutation
Create an interest or list of interests with **useCreateInterestsMutation**

> This hook provides the mutation function to create the underlying model's data. It is helpful in subscribing to topic or list of topics
The mutation is called only when there is no existing `tagSubscriptionId` for the given profile. If it exists, [useUpdateInterestsMutation](#useupdateinterestsmutation) should be used instead.

**Example usage**
```jsx
import { useCreateInterestsMutation } from  '@akashaorg/ui-awf-hooks/lib/generated'
import getSDK from '@akashaorg/awf-sdk';

const sdk = getSDK();
const [createInterests, { data, error, loading }] = useCreateInterestsMutation(
  {
    context: {
      source: sdk.services.gql.contextSources.composeDB
    },
  }
);

const tagSubscriptionId = null; // use createInterestsMutation, only when there is no tag subscription id.

const handleCreateInterests = () => {
  if (!tagSubscriptionId) {
    createInterests({
    variables: {
      i: {
        content: {
          topics: [{
            value: 'akasha',
            labelType: sdk.services.gql.labelTypes.INTEREST
          },
          {
            value: 'world',
            labelType: sdk.services.gql.labelTypes.INTEREST
          }
          ]
        }
      }
    },
    onError,
    OnCompleted,
    ...
  }).then(
    // ...
  ).catch(
    // ...
  )
  }
}
```

### useCreateProfileMutation
Create a profile with **useCreateProfileMutation**

> This hook provides the mutation function to create the underlying model's data. It is helpful in creating new user profiles upon authentication.

**Example usage**
```jsx
import { useCreateProfileMutation } from  '@akashaorg/ui-awf-hooks/lib/generated'
import getSDK from '@akashaorg/awf-sdk';

const sdk = getSDK();
const [createProfile, { data, error, loading }] = useCreateProfileMutation(
  {
    context: {
      source: sdk.services.gql.contextSources.composeDB
    },
  }
);

const handleCreateProfile = () => {
  createProfile({
    variables: {
      i: {
        content: {
          nsfw: false,
          name: 'New Profile',
          description: 'this is a new profile',
          links: [
            {
              href: 'http://sociallink1'
            },
            {
              href: 'http://sociallink2'
            }
          ],
          avatar: '', // new profile's avatar
          background: '', // new profile's cover image
          createdAt: new Date().toISOString(),
        }
      }
    },
    onError,
    OnCompleted,
    ...
  }).then(
    // ...
  ).catch(
    // ...
  )
}
```

### useCreateReflectMutation
Create a reflection to a beam or a beam's reflection with **useCreateReflectMutation**

> This hook provides the mutation function to create the underlying model's data. It is helpful in creating a reflection to a beam.

**Example usage**
```jsx
import { useCreateReflectMutation } from  '@akashaorg/ui-awf-hooks/lib/generated'
import getSDK from '@akashaorg/awf-sdk';

const sdk = getSDK();
const [createReflection, { data, error, loading }] = useCreateReflectMutation(
  {
    context: {
      source: sdk.services.gql.contextSources.composeDB
    },
  }
);

const handleCreateReflection = () => {
  createReflection({
    variables: {
      i: {
        content: {
          active: true,
          beamId: 'beamId',
          content: [
            {
              label: 'label',
              propertyType: 'slate-block',
              value: 'encodedSlateContent'
            }
          ],
          reflection: 'reflectToId' // optional - used when reflecting to a reflection
          isReply: true // optional - used when reflecting to a reflection
          createdAt: new Date().toISOString(),
        }
      }
    },
    onError,
    OnCompleted,
    ...
  }).then(
    // ...
  ).catch(
    // ...
  )
}
```

### useIndexBeamMutation

### useIndexContentBlockMutation

### useIndexProfileMutation

### useIndexReflectionMutation

### useSetAppReleaseMutation
### useUpdateAkashaReflectMutation
### useUpdateAppMutation
### useUpdateAppReleaseMutation
### useUpdateBeamMutation
### useUpdateContentBlockMutation
### useUpdateFollowMutation
### useUpdateInterestsMutation
### useUpdateProfileMutation

## Queries